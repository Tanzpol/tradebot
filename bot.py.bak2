# bot.py
import os
import json
import threading
import time
from typing import Optional
from decimal import Decimal, ROUND_HALF_UP, getcontext

from binance.client import Client
from config import BINANCE_API_KEY, BINANCE_API_SECRET

# –¢–æ—á–Ω–æ—Å—Ç—å Decimal
getcontext().prec = 28

# –§–ª–∞–≥ —Ç–µ—Å—Ç–æ–≤–æ–π —Å–µ—Ç–∏ –∏ –∫–æ–º–∏—Å—Å–∏—è
TESTNET = os.getenv("BINANCE_TESTNET") == "1"
# –í testnet –∫–æ–º–∏—Å—Å–∏–∏ —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏ –Ω–µ—Ç; –≤ —Ä–µ–∞–ª–µ –±–µ—Ä—ë–º 0.075% (–µ—Å–ª–∏ –ø–ª–∞—Ç–∏—à—å BNB)
FEE_RATE_D = Decimal("0.00000") if TESTNET else Decimal("0.00075")


class TradeBot:
    def __init__(self):

    def _load_active_trades(self):
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–¥–µ–ª–∫–∏ –∏–∑ —Ñ–∞–π–ª–∞ –≤ –ø–∞–º—è—Ç—å."""
        from state import load_state
        state = load_state()
        self.active_trades = {
            t["id"]: t for t in state["trades"] if t["status"] == "open"
        }
        print(f"üîÅ –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(self.active_trades)} –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–¥–µ–ª–æ–∫")

        self.testnet = TESTNET
        self.client = Client(BINANCE_API_KEY, BINANCE_API_SECRET, testnet=self.testnet)

        self.current_price: Optional[float] = None

        # WebSocket –ø–æ—Ç–æ–∫ —Ü–µ–Ω—ã BTCUSDT
        self._ws_thread: Optional[threading.Thread] = None
        self._ws_stop = threading.Event()
        self._ws_started = False

        # –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –æ—Ç–∫—Ä—ã—Ç–æ–π —Å–¥–µ–ª–∫–∏
        self._mon_thread: Optional[threading.Thread] = None
        self._mon_stop = threading.Event()

        self.active_trades: Dict[int, dict] = {}  # –∫—ç—à –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–¥–µ–ª–æ–∫
        self._load_active_trades()

    # ---- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—Ç–µ—Ä—ã ----
    @staticmethod
    def _q2(q: Decimal) -> str:
        return str(q.quantize(Decimal("0.01"), rounding=ROUND_HALF_UP))

    @staticmethod
    def _q8(q: Decimal) -> str:
        return str(q.quantize(Decimal("0.00000001"), rounding=ROUND_HALF_UP))

    # ---- WebSocket BTCUSDT ----
    def _ws_loop(self):
        import websocket  # –∏–º–ø–æ—Ä—Ç –≤–Ω—É—Ç—Ä–∏ –ø–æ—Ç–æ–∫–∞, —á—Ç–æ–±—ã –Ω–µ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤–∞—Ç—å —Å uvicorn
        url = "wss://stream.binance.com:9443/ws/btcusdt@trade"

        def on_message(ws, message):
            try:
                msg = json.loads(message)
                p = float(msg.get("p"))
                self.current_price = p
            except Exception:
                pass

        def on_error(ws, err):
            print("WS error:", err)

        def on_close(ws, code, reason):
            print("WS closed:", code, reason)

        while not self._ws_stop.is_set():
            try:
                ws = websocket.WebSocketApp(
                    url,
                    on_message=on_message,
                    on_error=on_error,
                    on_close=on_close,
                )
                ws.run_forever(ping_interval=20, ping_timeout=10)
            except Exception as e:
                print("WS exception:", e)
            if not self._ws_stop.is_set():
                time.sleep(2)

    def start_price_stream(self):
        if self._ws_started:
            return
        self._ws_stop.clear()
        self._ws_thread = threading.Thread(target=self._ws_loop, daemon=True)
        self._ws_thread.start()
        self._ws_started = True

    def stop_price_stream(self):
        if not self._ws_started:
            return
        self._ws_stop.set()
        self._ws_started = False

    # ---- –†–∞—Å—á—ë—Ç—ã PnL ----
    def _pnl_usdc_now(self, qty_btc_str: str, spent_usdc_str: str, price: Optional[float]) -> Optional[Decimal]:
        """–¢–µ–∫—É—â–∏–π PnL –≤ USDC —Å —É—á—ë—Ç–æ–º –∫–æ–º–∏—Å—Å–∏–∏ –ø—Ä–æ–¥–∞–∂–∏."""
        if price is None:
            return None
        qty = Decimal(qty_btc_str)
        spent = Decimal(spent_usdc_str)
        gross = qty * Decimal(str(price))
        fee = (gross * FEE_RATE_D)
        return gross - fee - spent

    # ---- –¢–æ—Ä–≥–æ–≤–ª—è ----
    def buy(self, symbol: str, amount_usdc: float, take_profit: float, stop_loss: float, trailing: float):
    def buy(self, symbol: str, amount_usdc: float, take_profit: float, stop_loss: float, trailing: float):
        """
        –ü–æ–∫—É–ø–∫–∞ MARKET-–æ—Ä–¥–µ—Ä–æ–º –Ω–∞ —Å—É–º–º—É –≤ USDC.
        """
        from decimal import Decimal, ROUND_HALF_UP
        from state import add_trade as state_add_trade

        quote_qty = Decimal(str(amount_usdc)).quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)
        if quote_qty <= 0:
            raise ValueError("amount_usdc must be > 0")

        order = self.client.create_order(
            symbol=symbol,
            side="BUY",
            type="MARKET",
            quoteOrderQty=str(quote_qty),
        )

        executed_qty = Decimal(order.get("executedQty", "0"))
        cumm_quote = Decimal(order.get("cummulativeQuoteQty", "0"))
        avg_price = (cumm_quote / executed_qty) if executed_qty > 0 else None

        # –§–∏–∫—Å–∏—Ä—É–µ–º –∑–Ω–∞—á–µ–Ω–∏—è
        entry_price_str = self._q2(avg_price) if avg_price is not None else None
        spent_usdc_str = self._q2(cumm_quote)
        qty_btc_str = self._q8(executed_qty)

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ —Ñ–∞–π–ª —á–µ—Ä–µ–∑ state.py
        trade = state_add_trade(
            symbol=symbol,
            amount_usdc=float(quote_qty),
            entry_price=float(entry_price_str) if entry_price_str else 0.0,
            qty=float(qty_btc_str),
            spent_usdc=float(spent_usdc_str),
            # –¥–æ–ø. –ø–æ–ª—è
            take_profit_usdc=take_profit,
            stop_loss_usdc=stop_loss,
            trailing_percent=trailing,
            high_watermark=float(avg_price) if avg_price is not None else None,
        )

        # –ö—ç—à–∏—Ä—É–µ–º –≤ –ø–∞–º—è—Ç–∏
        self.active_trades[trade["id"]] = trade

        # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–æ—Ç–æ–∫–∏, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        self.start_price_stream(symbol)
        self._start_monitor()

        return trade
    def _start_monitor(self):
        self._stop_monitor()
        self._mon_stop.clear()
        self._mon_thread = threading.Thread(target=self._monitor_loop, daemon=True)
        self._mon_thread.start()

    def _stop_monitor(self):
        try:
            if self._mon_thread and self._mon_thread.is_alive():
                self._mon_stop.set()
                self._mon_thread.join(timeout=1.0)
        except Exception:
            pass
        finally:
            self._mon_thread = None
            self._mon_stop.clear()

    def _monitor_loop(self):
        """–ü–æ—Å—Ç–æ—è–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏–π –≤—ã—Ö–æ–¥–∞ –¥–ª—è –≤—Å–µ—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–¥–µ–ª–æ–∫."""
        while not self._mon_stop.is_set():
            try:
                # –†–∞–±–æ—Ç–∞–µ–º —Å –∫–æ–ø–∏–µ–π, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏–π –≤–æ –≤—Ä–µ–º—è –∏—Ç–µ—Ä–∞—Ü–∏–∏
                trade_ids = list(self.active_trades.keys())
                for tid in trade_ids:
                    if tid not in self.active_trades:
                        continue
                    trade = self.active_trades[tid]
                    symbol = trade["symbol"]
                    price = self.current_prices.get(symbol)
                    if not trade or trade.get("status") != "open" or price is None:
                        continue

                    qty_str = str(trade["qty"])
                    spent_str = str(trade["spent_usdc"])
                    tp_usd = trade["take_profit_usdc"]
                    sl_usd = trade["stop_loss_usdc"]
                    trailing_pct = trade["trailing_percent"]

                    # –û–±–Ω–æ–≤–ª—è–µ–º –º–∞–∫—Å–∏–º—É–º —Ü–µ–Ω—ã –ø–æ—Å–ª–µ –≤—Ö–æ–¥–∞
                    if trade["high_watermark"] is None or price > trade["high_watermark":
                        trade["high_watermark"] = price
                        self._sync_trade_to_state(trade)

                    pnl = self._pnl_usdc_now(qty_str, spent_str, price)
                    if pnl is None:
                        continue

                    # 1) Stop-Loss $
                    if sl_usd > 0 and pnl <= Decimal(str(-abs(sl_usd))):
                        trade["last_reason"] = f"STOP LOSS ${sl_usd} (PnL={pnl.quantize(Decimal('0.01'))})"
                        self._sell_all(tid)
                        continue

                    # 2) Take Profit $
                    if tp_usd > 0 and pnl >= Decimal(str(abs(tp_usd))):
                        trade["last_reason"] = f"TAKE PROFIT ${tp_usd} (PnL={pnl.quantize(Decimal('0.01'))})"
                        self._sell_all(tid)
                        continue

                    # 3) Trailing Take Profit %
                    hw = trade.get("high_watermark")
                    if hw and trailing_pct > 0:
                        drop_trigger = hw * (1 - float(trailing_pct) / 100.0)
                        if price < drop_trigger and pnl > Decimal("0"):
                            trade["last_reason"] = (
                                f"TRAILING {trailing_pct}% (from {hw:.2f} "
                                f"to {price:.2f}, PnL={pnl.quantize(Decimal('0.01'))})"
                            )
                            self._sell_all(tid)
                            continue
            except Exception as e:
                print("Monitor error:", e)
            time.sleep(0.2)
    def _sell_all(self, trade_id: int):
    def _sell_all(self, trade_id: int):
        """MARKET-–ø—Ä–æ–¥–∞–∂–∞ –≤—Å–µ–≥–æ –æ–±—ä—ë–º–∞ –ø–æ —Ä—ã–Ω–∫—É, –∑–∞–∫—Ä—ã—Ç–∏–µ —Å–¥–µ–ª–∫–∏."""
        if trade_id not in self.active_trades:
            return
        trade = self.active_trades[trade_id]
        if trade.get("status") != "open":
            return

        qty = Decimal(str(trade["qty"]))
        symbol = trade["symbol"]
        qty_str = str(qty.normalize())

        try:
            order = self.client.create_order(
                symbol=symbol,
                side="SELL",
                type="MARKET",
                quantity=qty_str,
            )
            trade["close_order_id"] = order.get("orderId")
            cumm_quote = Decimal(order.get("cummulativeQuoteQty", "0"))
            fee = (cumm_quote * FEE_RATE_D)
            pnl = cumm_quote - fee - Decimal(str(trade["spent_usdc"]))
            trade["realized_pnl_usdc"] = str(pnl.quantize(Decimal("0.01"), rounding=ROUND_HALF_UP))
            trade["status"] = "closed"
            self._sync_trade_to_state(trade)
        except Exception as e:
            trade["last_reason"] = f"SELL ERROR: {e}"
            self._sync_trade_to_state(trade)

        # –£–¥–∞–ª—è–µ–º –∏–∑ –∫—ç—à–∞
        if trade_id in self.active_trades:
            del self.active_trades[trade_id]
    def status(self):
        """
        –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è UI.
        """
        from state import load_state
        base = {
            "status": "running",
            "testnet": self.testnet,
            "active_count": len(self.active_trades),
        }
        # –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—É—â–∏–µ —Ü–µ–Ω—ã
        base["prices"] = self.current_prices
        # –î–æ–±–∞–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–¥–µ–ª–∫–∏
        base["trades"] = list(self.active_trades.values())
        return base
